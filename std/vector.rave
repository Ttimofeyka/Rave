/*
This Source Code Form is subject to the terms of the Mozilla
Public License, v. 2.0. If a copy of the MPL was not distributed
with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

import <std/memory> <std/map>

namespace std {
    (data: "data", length: "length", @tNequals(VECTOR_T, void)) struct vector<VECTOR_T> {
        (noOperators) VECTOR_T* data;
        int capacity;
        int length;

        (arrayable) std::vector<VECTOR_T> this {
            std::vector<VECTOR_T> this;
            this.data = cast(VECTOR_T*)std::malloc(sizeof(VECTOR_T));
            this.capacity = sizeof(VECTOR_T);
            this.length = 0;
        } => this;

        std::vector<VECTOR_T> this(int size) {
            std::vector<VECTOR_T> this;
            this.data = cast(VECTOR_T*)std::malloc(sizeof(VECTOR_T) * size);
            this.capacity = sizeof(VECTOR_T) * size;
            this.length = size;
        } => this;

        std::vector<VECTOR_T> this(VECTOR_T* data, int size) {
            std::vector<VECTOR_T> this;
            this.data = cast(VECTOR_T*)std::malloc(sizeof(VECTOR_T) * size);
            this.capacity = sizeof(VECTOR_T) * size;
            this.length = size;
            std::memcpy(cast(char*)this.data, cast(char*)data, size * sizeof(VECTOR_T));
        } => this;

        void add(VECTOR_T value) {
            if((this.length * sizeof(VECTOR_T)) == this.capacity) {
                this.data = cast(VECTOR_T*)std::realloc(cast(void*)this.data, this.capacity, this.capacity * 2);
                this.capacity = this.capacity * 2;
            }
            this.data[this.length] = value;
            this.length = this.length + 1;
        }

        (inline) void assign(std::vector<VECTOR_T> of) {
            for(int i=0; i<of.length; i+=1) {this.add(of.data[i]);}
        }

        (inline) void set(int index, VECTOR_T value) {
            @if(__RAVE_RUNTIME_CHECKS) {
                if((index >= 0) && (index < this.length)) this.data[index] = value;
            };

            @if(!(__RAVE_RUNTIME_CHECKS)) {
                this.data[index] = value;
            };
        }

        void zero {
            for(int i=0; i<this.length; i++) this.data[i] = null;
        }

        std::vector<VECTOR_T> copy {
            std::vector<VECTOR_T> buffer;
            buffer.data = cast(VECTOR_T*)std::malloc(sizeof(std::vector<VECTOR_T>));
            buffer.capacity = this.capacity;
            buffer.length = this.length;

            for(int i=0; i<this.length; i+=1) buffer.set(i, this.data[i]);
        } => buffer;

        (inline) VECTOR_T operator[](std::vector<VECTOR_T>* v, int index) {
            @if(__RAVE_RUNTIME_CHECKS) {
                if((index >= 0) && (index < v.length)) return = v.data[index];
            };

            @if(!(__RAVE_RUNTIME_CHECKS)) {
                return = v.data[index];
            };
        }

        (inline) void operator[]=(std::vector<VECTOR_T>* v, int index, VECTOR_T value) {
            @if(__RAVE_RUNTIME_CHECKS) {
                if((index >= 0) && (index < v.length)) v.data[index] = value;
            };

            @if(!(__RAVE_RUNTIME_CHECKS)) {
                v.data[index] = value;
            };
        }

        (inline) void swap(int first, int second) {
            @if(__RAVE_RUNTIME_CHECKS) {
                if(((first >= 0) && (first < this.length)) && ((second >= 0) && (second < this.length))) {
                    (noOperators) VECTOR_T temp = this.data[first];
                    this.data[first] = this.data[second];
                    this.data[second] = temp;
                }
            };

            @if(!(__RAVE_RUNTIME_CHECKS)) {
                (noOperators) VECTOR_T temp = this.data[first];
                this.data[first] = this.data[second];
                this.data[second] = temp;
            };
        }

        std::vector<VECTOR_T> operator+(std::vector<VECTOR_T> one, std::vector<VECTOR_T> two) {
            std::vector<VECTOR_T> cp = one.copy();
            cp.assign(two);
        } => cp;

        void remove(int index) {
            @if(__RAVE_RUNTIME_CHECKS) {
                if((index >= 0) && (index < this.length)) {
                    for(int i=index; i<this.length; i+=1) {
                        if((i+1) < this.length) this.data[i] = this.data[i+1];
                    }
                    this.length = this.length - 1;
                }
            };

            @if(!(__RAVE_RUNTIME_CHECKS)) {
                for(int i=index; i<this.length; i+=1) {
                    if((i+1) < this.length) this.data[i] = this.data[i+1];
                }
                this.length = this.length - 1;
            };
        }

        (inline) void removeLast {
            @if(__RAVE_RUNTIME_CHECKS) {
                if(this.length > 0) this.remove(this.length-1);
            };

            @if(!(__RAVE_RUNTIME_CHECKS)) {
                this.remove(this.length-1);
            };
        }

        void ~this {
            if(this.data != null) {
                std::free(cast(void*)this.data);
                this.data = null;
                this.length = 0;
                this.capacity = 0;
            }
        }

        void transform(VECTOR_T(VECTOR_T) fn) {
            for(int i=0; i<this.length; i++) this.data[i] = fn(this.data[i]);
        }

        int hash {
            return = this.length;
            for(int i=0; i<this.length; i++) return = return * i + 7588 + (return <. 6) + (return >. 2);
        }
    }
}
