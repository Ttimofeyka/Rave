/*
This Source Code Form is subject to the terms of the Mozilla
Public License, v. 2.0. If a copy of the MPL was not distributed
with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

namespace std {
    namespace math {
        alias PI = 3.14159265358979323846d;
        alias PI_f = 3.141592653589793f;
        alias PI_hf = 3.140625h;

        (inline) double degToRad(double d) => (d * std::math::PI / 180d);
        (inline) float degToRad(float d) => (d * std::math::PI_f / 180f);
        (inline) half degToRad(half hf) => (hf * std::math::PI_hf / 180h);

        (inline) double radToDeg(double r) => (r * 180 / std::math::PI);
        (inline) float radToDeg(float r) => (r * 180f / std::math::PI_f);
        (inline) half radToDeg(half r) => (r * 180h / std::math::PI_hf);

        long factorial(int n) {
            return = 1;
            int i = 1;
            while(i <= n) {
                return = return * i;
                i += 1;
            }
        }

        (inline, @tNequals(ABS_T, void)) ABS_T abs<ABS_T>(ABS_T value) {
            return = value;
            if(value < cast(ABS_T)null) value = -value;
        }

        (inline, @tNequals(GETSIGN_T, void)) char getSign<GETSIGN_T>(GETSIGN_T value) {
            return = 1;
            if(value < cast(GETSIGN_T)null) return = -1;
        }

        (inline, @tNequals(COPYSIGN_T, void)) COPYSIGN_T copySign<COPYSIGN_T>(COPYSIGN_T v1, COPYSIGN_T v2) => std::math::abs(v1) * std::math::getSign(v2);

        double floor(double f) {
            return = (cast(double)(cast(long)f));
            if((return < 0) && (return != f)) return = return - 1d;
        }

        float floor(float f) {
            return = (cast(float)(cast(long)f));
            if((return < 0) && (return != f)) return = return - 1f;
        }

        half floor(half f) {
            return = (cast(half)(cast(int)f));
            if((return < 0) && (return != f)) return = return - 1h;
        }

        double ceil(double d) => -(std::math::floor(-d));
        float ceil(float f) => -(std::math::floor(-f));
        half ceil(half f) => -(std::math::floor(-f));

        double exp(double x) {
            return = 1.0 + x;
            double term = x;
            for(int k=2; k<50; k+=1) {
                term = term * x / cast(double)k;
                return = return + term;
            }
        }

        float exp(float x) {
            return = 1.0 + x;
            float term = x;
            for(int k=2; k<50; k+=1) {
                term = term * x / cast(float)k;
                return = return + term;
            }
        }

        double loge(double x) {
            if(x <= 0) return = 0d;
            else {
                int powAdj = 0;
                while(x > 1.0) {
                    x = x / 2.718281828459045235;
                    powAdj += 1;
                }
                while(x < 0.25) {
                    x = x * 2.718281828459045235;
                    powAdj -= 1;
                }

                x -= 1.0;
                double t = 0.0;
                double s = 1.0;
                double z = x;
                for(int k=1; k<=50; k+=1) {
                    t = t + (z * s) / k;
                    z = z * x;
                    s = -s;
                }

                return = t + powAdj;
            }
        }

        float loge(float x) {
            if(x <= 0) return = 0f;
            else {
                int powAdj = 0;
                while(x > 1.0) {
                    x = x / 2.718281828459045235;
                    powAdj += 1;
                }
                while(x < 0.25) {
                    x = x * 2.718281828459045235;
                    powAdj -= 1;
                }

                x -= 1.0;
                float t = 0.0;
                float s = 1.0;
                float z = x;
                for(int k=1; k<=50; k+=1) {
                    t = t + (z * s) / k;
                    z = z * x;
                    s = -s;
                }

                return = t + powAdj;
            }
        }

        (inline) double log(double x) => std::math::loge(x) / std::math::loge(10.0);
        (inline) float log(float x) => std::math::loge(x) / std::math::loge(10.0);

        double sqrt(double d) {
            return = 1.0;
            for(int i=0; i<=10; i+=1) return = return - (((return * return) - d) / (2d * return));
        }

        float sqrt(float f) => cast(float)std::math::sqrt(cast(double)f);
        half sqrt(half hf) => cast(half)std::math::sqrt(cast(double)hf);

        double acos(double d) {
            double negate = cast(double)(d < 0.0);
            d = std::math::abs(d);
            double result = -0.0187293;
            result = result * d;
            result = result + 0.0742610;
            result = result * d;
            result = result - 0.2121144;
            result = result * d;
            result = result + 1.5707288;
            result = result * std::math::sqrt(1.0 - d);
            result = result - 2 * negate * result;
        } => ((negate * std::math::PI) + result);

        float acos(float f) {
            float negate = cast(float)(f < 0.0);
            f = std::math::abs(f);
            float result = -0.0187293;
            result = result * f;
            result = result + 0.0742610;
            result = result * f;
            result = result - 0.2121144;
            result = result * f;
            result = result + 1.5707288;
            result = result * std::math::sqrt(1.0 - f);
            result = result - 2 * negate * result;
        } => ((negate * std::math::PI) + result);

        double asin(double x) => (std::math::PI / 2.0) - std::math::sqrt(1.0 - x) * (1.5707288 + (-0.2121144) * x + 0.0742610 * (x * x) + -0.0187293 * (x * x * x));
        float asin(float x) => (std::math::PI_f / 2.0f) - std::math::sqrt(1.0f - x) * (1.5707288f + (-0.2121144f) * x + 0.0742610f * (x * x) + (-0.0187293f) * (x * x * x));

        double coshn(double d, int n) {
            double c = 1.0d;
            double f = 1.0d;
            double xp = 1.0d;
            for(int i=1; i<n; i+=1) {
                f = f * ((2 * i - 1) * (2 * i));
                xp = xp * (d * d);
                c += xp / f;
            }
        } => c;

        float coshn(float d, int n) {
            float c = 1.0f;
            float f = 1.0f;
            float xp = 1.0f;
            for(int i=1; i<n; i+=1) {
                f = f * ((2 * i - 1) * (2 * i));
                xp = xp * (d * d);
                c += xp / f;
            }
        } => c;

        double cosh(double x) => 0.5 * (std::math::exp(x) + std::math::exp(-x));
        float cosh(float x) => 0.5f * (std::math::exp(x) + std::math::exp(-x));

        double sinh(double x) => 0.5 * (std::math::exp(x) - std::math::exp(-x));
        float sinh(float x) => 0.5f * (std::math::exp(x) - std::math::exp(-x));

        double tanh(double x) => (std::math::exp(2.0 * x) - 1d) / (std::math::exp(2.0 * x) + 1.0);
        float tanh(float x) => (std::math::exp(2.0 * x) - 1f) / (std::math::exp(2.0 * x) + 1.0);

        double dtanh(double x) => 1d - (x * x);
        float dtanh(float x) => 1f - (x * x);

        double acosh(double x) => std::math::log(x + std::math::sqrt((x + 1.0) * (x - 1.0)));
        float acosh(float x) => std::math::log(x + std::math::sqrt((x + 1.0) * (x - 1.0)));

        double asinh(double x) => std::math::log(x + std::math::sqrt(x * x + 1.0));
        float asinh(float x) => std::math::log(x + std::math::sqrt(x * x + 1.0));

        double atanh(double x) => 0.5 * (std::math::log(1.0 + x) - std::math::log(1.0 - x));
        float atanh(float x) => 0.5f * (std::math::log(1.0 + x) - std::math::log(1.0 - x));

        double erf(double x) {
            x = std::math::abs(x);
            double t = 1.0 / (1.0 + (0.3275911 * x));
            double y = 1.0 - (((((1.061405429 * t + (-1.453152027)) * t) + 1.421413741) * t + (-0.284496736)) * t + 0.254829592) * t * std::math::exp(-x * x);
        } => std::math::getSign(x) * y;

        float erf(float x) {
            x = std::math::abs(x);
            float t = 1.0 / (1.0 + (0.3275911 * x));
            float y = 1.0 - (((((1.061405429 * t + (-1.453152027)) * t) + 1.421413741) * t + (-0.284496736)) * t + 0.254829592) * t * std::math::exp(-x * x);
        } => std::math::getSign(x) * y;

        double pow(double f, double f2) {
            if(f2 < 0) return = 1 / std::math::pow(f, -f2);
            else if((f2 > 0.0) && (f2 < 1.0)) return = std::math::exp(f2 * std::math::loge(f));
            else {
                if(std::math::floor(f2) != f2) {
                    if(f < 0d) return = 0d;
                    else return = std::math::exp(f2 * std::math::loge(f));
                }
                else {
                    double r = 1.0;
                    while(f2 > 0) {
                        r = r * f;
                        f2 = f2 - 1;
                    }
                    if(f2 > 0) r = r * f * f2;
                    return = r;
                }
            }
            if((f < 0d) && (return > 0d)) return = -return;
        }

        float pow(float f, float f2) {
            if(f2 < 0) return = 1 / std::math::pow(f, -f2);
            else if((f2 > 0.0) && (f2 < 1.0)) return = std::math::exp(f2 * std::math::loge(f));
            else {
                if(std::math::floor(f2) != f2) {
                    if(f < 0f) return = 0f;
                    else return = std::math::exp(f2 * std::math::loge(f));
                }
                else {
                    float r = 1.0;
                    while(f2 > 0) {
                        r = r * f;
                        f2 = f2 - 1;
                    }
                    if(f2 > 0) r = r * f * f2;
                    return = r;
                }
            }
            if((f < 0f) && (return > 0f)) return = -return;
        }

        double cbrt(double d) {
            if(d < 0.0d) return = (-1.0d * std::math::pow(-1.0d * d, 1.0d / 3.0d));
            else return = std::math::pow(d, 1.0d / 3.0d);
        }

        float cbrt(float f) {
            if(f < 0.0f) return = (-1.0f * std::math::pow(-1.0f * f, 1.0f / 3.0f));
            else return = std::math::pow(f, 1.0f / 3.0f);
        }
        
        double cos(double d) {
            while(d < 0.0) d = d + (2.0 * std::math::PI);
            while(d > (2.0 * std::math::PI)) d = d - (2.0 * std::math::PI);
            double t = 1.0;
            double cos = t;
            for(int i=1; i<40; i+=1) {
                double mult = (-d) * (d / ((2*i)*(2*i-1)));
                t = t * mult;
                cos = cos + t;
            }
        } => cos;

        float cos(float f) {
            while(f < 0.0) f = f + (2.0 * std::math::PI);
            while(f > (2.0 * std::math::PI)) f = f - (2.0 * std::math::PI);
            float t = 1.0;
            float cos = t;
            for(int i=1; i<40; i+=1) {
                float mult = (-f) * (f / ((2*i)*(2*i-1)));
                t = t * mult;
                cos = cos + t;
            }
        } => cos;

        (@tNequals(SIGN_T, void)) char sign<SIGN_T>(SIGN_T x) {
            if(x < cast(SIGN_T)null) return = -1;
            else if(x == cast(SIGN_T)null) return = 0;
            else return = 1;
        }

        (@tNequals(MIN_T, void)) MIN_T min<MIN_T>(MIN_T one, MIN_T two) {
            return = one;
            if(two < one) return = two;
        }

        (@tNequals(MAX_T, void)) MAX_T max<MAX_T>(MAX_T one, MAX_T two) {
            return = one;
            if(two > one) return = two;
        }

        double sin(double x) {
            double t = x;
            double sine = t;
            
            for(int i=1; i<=20; i+=1) {
                double mult = (-x) * (x / ((2*i+1)*(2*i)));
                t = t * mult;
                sine = sine + t;
            }
        } => sine;

        float sin(float x) {
            float t = x;
            float sine = t;
            
            for(int i=1; i<=20; i+=1) {
                float mult = (-x) * (x / ((2*i+1)*(2*i)));
                t = t * mult;
                sine = sine + t;
            }
        } => sine;

        double fma(double a, double b, double c) => (a * b) + c;
        float fma(float a, float b, float c) => (a * b) + c;
        half fma(half a, half b, half c) => (a * b) + c;

        double tan(double d) => std::math::sin(d) / std::math::cos(d);
        float tan(float f) => std::math::sin(f) / std::math::cos(f);

        double mod(double x) {
            return = 1.0d;
            if((x % 1.0d) != 0.0d) return = (x % 1.0d);
        }

        float mod(float x) {
            return = 1.0f;
            if((x % 1.0f) != 0.0f) return = (x % 1.0f);
        }

        half mod(half x) {
            return = 1.0h;
            if((x % 1.0h) != 0.0h) return = (x % 1.0h);
        }

        double round(double x, int n) {
            x = x * std::math::pow(10.0, cast(double)n);
            x += 0.5;
            x = std::math::floor(x) / std::math::pow(10.0, cast(double)n);
        } => x;

        float round(float x, int n) {
            x = x * std::math::pow(10.0f, cast(float)n);
            x += 0.5f;
            x = std::math::floor(x) / std::math::pow(10.0f, cast(float)n);
        } => x;

        bool isPrime(int number) {
            bool result = true;
            if(number == 1) result = false;
            else for(int i=2; (i*i) <= number; i+=1) {
                if(number % i == 0) {
                    result = false;
                    break;
                }
            }
        } => result;
        
        double sigmoid(double x) => 1d / (1d + std::math::exp(-x));
        float sigmoid(float x) => 1f / (1f + std::math::exp(-x));

        double dsigmoid(double x) => x * (1 - x);
        float dsigmoid(float x) => x * (1 - x);
        half dsigmoid(half x) => x * (1 - x);

        void softmax(double* x, int size) {
            double maxValue = x[0];
            double sum;

            for(int i=1; i<size; i++) {
                if(x[i] > maxValue) maxValue = x[i];
            }

            for(int i=0; i<size; i++) {
                x[i] = std::math::exp(x[i] - maxValue);
                sum += x[i];
            }

            for(int i=0; i<size; i++) x[i] /= sum;
        }

        void softmax(float* x, int size) {
            float maxValue = x[0];
            float sum;

            for(int i=1; i<size; i++) {
                if(x[i] > maxValue) maxValue = x[i];
            }

            for(int i=0; i<size; i++) {
                x[i] = std::math::exp(x[i] - maxValue);
                sum += x[i];
            }

            for(int i=0; i<size; i++) x[i] /= sum;
        }

        void rmsnorm(double* out, double* x, double* weight, int size) {
            double ss;

            for(int i=0; i<size; i++) ss += x[i] * x[i];
            ss /= cast(double)size;
            ss += 0.00001d;
            ss = 1d / std::math::sqrt(ss);

            for(int i=0; i<size; i++) out[i] = weight[i] * (ss * x[i]);
        }

        void rmsnorm(float* out, float* x, float* weight, int size) {
            float ss;

            for(int i=0; i<size; i++) ss += x[i] * x[i];
            ss /= cast(float)size;
            ss += 0.00001f;
            ss = 1f / std::math::sqrt(ss);

            for(int i=0; i<size; i++) out[i] = weight[i] * (ss * x[i]);
        }

        double relu(double x) => std::math::max(0.0d, x);
        float relu(float x) => std::math::max(0.0f, x);
        half relu(half x) => std::math::max(0.0h, x);

        double drelu(double x) {
            if(x >= 0.0) return = 1.0d;
            else return = 0.0d;
        }

        float drelu(float x) {
            if(x >= 0.0) return = 1.0f;
            else return = 0.0f;
        }

        half drelu(half x) {
            if(x >= 0.0) return = 1.0h;
            else return = 0.0h;
        }
    }
}
