/*
This Source Code Form is subject to the terms of the Mozilla
Public License, v. 2.0. If a copy of the MPL was not distributed
with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

import <std/string> <std/vector> <std/socket> <std/map> <std/io>

namespace std {
    namespace http {
        struct Response {
            std::hashmap<std::string, std::string> headers;
            std::string body;
            int status;
            int success;

            std::http::Response this {
                std::http::Response this;

                this.headers = std::hashmap<std::string, std::string>();
                this.body = "";
                this.status = 0;
                this.success = 0;
            } => this;

            void ~this {
                ~(this.headers);
                ~(this.body);
                this.status = 0;
                this.success = 0;
            }
        }

        struct Connection {
            std::socket socket;

            std::string protocol, host, path;
            char* port;

            std::http::Connection this(char* url, char* port) {
                std::http::Connection this;

                this.socket = std::socket();
                this.protocol = "";
                this.host = "";
                this.path = "/";
                this.port = port;

                usize p = 0;
                usize state = 0;

                while(url[p] != '\0') {
                    if(state == 0) {
                        if(url[p] != ':') {
                            this.protocol.add(url[p]);
                            p += 1;
                        }
                        else {
                            p += 3; // Skip the double slash
                            state += 1;
                        }
                    }
                    else {
                        if(state == 1) {
                            if(url[p] != '/') this.host.add(url[p]);
                            else state += 1;
                        }
                        else this.path.add(url[p]);

                        p += 1;
                    }
                }
            } => this;

            int open {
                char[46] hostBuffer;
                char* connHost = host.data;

                if(!std::ipv4::isValid(host.data)) {
                    std::socket::addrinfo* res;
                    std::socket::getAddrInfo(host.data, port, cast(std::socket::addrinfo*)0, &res);

                    for(std::socket::addrinfo* i = res; i != cast(std::socket::addrinfo*)0; i=i.ai_next) {
                        if(i.ai_addr.sa_family == std::socket::AfInet) {
                            std::socket::sockaddr_in* p = cast(std::socket::sockaddr_in*)i.ai_addr;
                            std::socket::inetNtop(std::socket::AfInet, p.&sin_addr, &hostBuffer, 46);
                            connHost = &hostBuffer;
                            break;
                        }

                        // TODO: IPv6 support
                    }

                    std::socket::freeAddrInfo(res);
                }

                if(socket.open(connHost, std::cstring::stol(port), std::socket::InAddrBroadcast) == -1) return = -1;
                else if(socket.connect() < 0) return = -2;
            }

            // Primitives

            (inline) int write(std::cstring buffer) => socket.write(buffer.data, buffer.length);
            (inline) int write(std::string buffer) => socket.write(buffer.data, buffer.length);

            (inline) int read(char* buffer, int length) => socket.read(buffer, length);

            (inline) int close => socket.close();

            // HTTP/1.1 request (write + read)
            std::http::Response request(std::cstring method, std::hashmap<std::string, std::string>* headers, std::cstring body) {
                std::string req = std::sprint(method, " ", path, " HTTP/1.1\r\nHost: ", host, "\r\n");
                defer ~req;

                if(headers != null) {
                    std::hashmap::iterator<std::string, std::string> iterator;
                    headers.next(&iterator);

                    while(iterator.current != null) {
                        req.append(iterator.current.key);
                        req.appendC(": ", 2);
                        req.append(iterator.current.value);
                        req.appendC("\r\n", 2);
                        headers.next(&iterator);
                    }
                }

                req.appendC("\r\n", 2);
                req.appendC(body.data, body.length);

                char[513] buf;

                if(socket.write(req) < 0) {
                    return.status = -1;
                    return.success = -1; // Bad write
                    @return();
                }

                return = std::http::Response();

                bool isR = false;
                bool isValueMode = false;

                std::string headerName = "";
                defer ~headerName;

                std::string headerValue = "";
                defer ~headerValue;

                long contentLength = -1;
                int readed = socket.read(&buf, 1);

                // Parse first line (skip HTTP version, get status, skip message)
                while((std::ascii::isSpace(buf[0])) && (readed > 0)) readed = socket.read(&buf, 1);
                while((!std::ascii::isSpace(buf[0])) && (readed > 0)) readed = socket.read(&buf, 1);
                while((std::ascii::isSpace(buf[0])) && (readed > 0)) readed = socket.read(&buf, 1);

                // Status
                std::string status = "";
                defer ~status;

                while((!std::ascii::isSpace(buf[0])) && (readed > 0)) {
                    status.add(buf[0]);
                    readed = socket.read(&buf, 1);
                }

                if(status.length > 0) return.status = status.toInt();
                else {
                    return.status = -1;
                    return.success = -2; // Bad HTTP status
                    @return();
                }

                while((std::ascii::isSpace(buf[0])) && (readed > 0)) readed = socket.read(&buf, 1);
                while((!std::ascii::isSpace(buf[0])) && (readed > 0)) readed = socket.read(&buf, 1);
                while((std::ascii::isSpace(buf[0])) && (readed > 0)) readed = socket.read(&buf, 1);

                while(readed > 0) {
                    if(buf[0] == '\r') {
                        if(headerName.length == 14) {
                            char* cl = "content-length";
                            bool isEqual = true;

                            for(usize i=0; i<14; i++) {
                                if(std::ascii::toLower(headerName.data[i]) != cl[i]) {isEqual = false; break;}
                            }

                            if(isEqual) contentLength = headerValue.toInt();
                        }

                        if(headerName.length > 0) {
                            return.headers.set(headerName, headerValue);

                            headerName = std::string("");
                            headerValue = std::string("");
                        }

                        isR = true;
                        isValueMode = false;

                        readed = socket.read(&buf, 1);
                    }
                    else if((buf[0] == '\n') && (isR)) {
                        isR = false;

                        // New header or the start of body?
                        readed = socket.read(&buf, 1);

                        if(buf[0] == '\r') {
                            // Body
                            readed = socket.read(&buf, 1);
                            if(buf[0] == '\n') break;
                        }
                    }
                    else if(!isValueMode) {
                        if(buf[0] == ':') {
                            isValueMode = true;
                            readed = socket.read(&buf, 1);

                            while((std::ascii::isSpace(buf[0])) && (readed > 0)) readed = socket.read(&buf, 1);
                        }
                        else if(std::ascii::isSpace(buf[0])) readed = socket.read(&buf, 1);
                        else {
                            headerName.add(buf[0]);
                            readed = socket.read(&buf, 1);
                        }
                    }
                    else {
                        headerValue.add(buf[0]);
                        readed = socket.read(&buf, 1);
                    }
                }

                if(contentLength > 0) {
                    while(contentLength >= 512) {
                        readed = socket.read(&buf, 512);
                        if(readed > 0) return.body.appendC(&buf, readed);

                        contentLength -= 512;
                    }

                    readed = socket.read(&buf, contentLength);
                    if(readed > 0) return.body.appendC(&buf, readed);
                }
                else if(contentLength != 0) {
                    socket.read(&buf, 512);

                    while(readed > 0) {
                        return.body.appendC(&buf, readed);
                        readed = socket.read(&buf, 512);
                    }
                }
            }

            void ~this {
                ~(this.socket);
                ~(this.protocol);
                ~(this.host);
                ~(this.path);
            }
        }
    }
}